msg = "I know you have this script, but I know you won't be able to use it hehehehahhahaha if you want this script so badly go to roblox studios to buy the plugin thanks xD."
def GetCode(gameid:int):
    return 		'if game.GameId == '+str(gameid)+' then local Vector3D = {} Vector3D.__index = Vector3D function Vector3D.new(x, y, z) local self = setmetatable({}, Vector3D) self.X = x or 0 self.Y = y or 0 self.Z = z or 0 self.Magnitude = math.sqrt(x^2 + y^2 + z^2) if self.Magnitude == 0 then self.Unit = function() return Vector3D.new(0, 0, 0) end else self.Unit = function() return Vector3D.new(self.X / self.Magnitude, self.Y / self.Magnitude, self.Z / self.Magnitude) end end return self end function Vector3D.__add(t1, t2) return Vector3D.new(t1.X + t2.X, t1.Y + t2.Y, t1.Z + t2.Z) end function Vector3D.__sub(t1, t2) return Vector3D.new(t1.X - t2.X, t1.Y - t2.Y, t1.Z - t2.Z) end function Vector3D.__mul(t1, t2) if type(t2) == "number" then return Vector3D.new(t1.X * t2, t1.Y * t2, t1.Z * t2) else return Vector3D.new(t1.X * t2.X, t1.Y * t2.Y, t1.Z * t2.Z) end end function Vector3D.__div(t1, t2) return Vector3D.new(t1.X / t2.X, t1.Y / t2.Y, t1.Z / t2.Z) end function Vector3D.__tostring(t1) return "{" .. "X: " .. t1.X .. ", Y: " .. t1.Y .. ", Z: " .. t1.Z .. "}" end function Vector3D.Calc(startPos, endPos, data) local Setting = {} Setting["difference"] = endPos - startPos Setting["distance"] = Setting["difference"].Magnitude Setting["direction"] = Setting["difference"]:Unit() if data["Time"] then Setting["Speed"] = data["Time"] / Setting["distance"] elseif data["speed"] then Setting["Time"] = Setting["distance"] / data["speed"] if data["speed"] <= 0 then Setting["Time"] = 0 end end if Setting["distance"] == 0 then Setting["Time"] = 0 Setting["Speed"] = 0 end return Setting end local Flipbook = {} Flipbook.__index = Flipbook function Flipbook.new(ImageLabel, size, flipbook_size, div) if not div or div <= 0 then div = 1 end local self = setmetatable({}, Flipbook) if not flipbook_size then flipbook_size = "None" return end local fliptable = string.split(flipbook_size, "X") local NumberOfFrames = tonumber(fliptable[1]) self.RobloxMaxImageSize = 1024 self.frame = {} self.connection = nil self.NumberOfFrames = math.pow(NumberOfFrames, 2) self.Timing = NumberOfFrames / (self.NumberOfFrames * div) self.Columns = tonumber(fliptable[1]) self.Rows = tonumber(fliptable[1]) self.frame = ImageLabel self.limit = 0 local ImageHeight = size.Y local ImageWidth = size.X local RealWidth local RealHeight if math.max(ImageWidth, ImageHeight) > self.RobloxMaxImageSize then local Longest = ImageWidth > ImageHeight and "Width" or "Height" if Longest == "Width" then RealWidth = self.RobloxMaxImageSize RealHeight = (RealWidth / ImageWidth) * ImageHeight elseif Longest == "Height" then RealHeight = self.RobloxMaxImageSize RealWidth = (RealHeight / ImageHeight) * ImageWidth end else RealWidth = ImageWidth RealHeight = ImageHeight end self.FrameSize = Vector2.new(RealWidth / self.Columns, RealHeight / self.Rows) self.frame.ImageRectSize = self.FrameSize self.CurrentRow, self.CurrentColumn = 0, 0 self.Offsets = {} self.Index = 0 self.tock = 0 return self end function Flipbook:Start() if #self.Offsets <= 0 then for i = 1, self.NumberOfFrames do local CurrentX = self.CurrentColumn * self.FrameSize.X local CurrentY = self.CurrentRow * self.FrameSize.Y table.insert(self.Offsets, Vector2.new(CurrentX, CurrentY)) self.CurrentColumn = self.CurrentColumn + 1 if self.CurrentColumn >= self.Columns then self.CurrentColumn = 0 self.CurrentRow = self.CurrentRow + 1 end end end return self end function Flipbook:increment() if tick() - self.tock > self.Timing and self.limit < self.NumberOfFrames then self.limit = self.limit + 1 self.tock = tick() self.Index = self.Index + 1 if self.Offsets[self.Index] then self.frame.ImageRectOffset = self.Offsets[self.Index] end if self.Index >= self.NumberOfFrames then self.Index = 0 end end end function Flipbook:Stop() if self.connection and self.frame then self.connection:Disconnect() self.frame.ImageRectOffset = Vector2.new(0, 0) self.frame.ImageRectSize = Vector2.new(0, 0) self.Offsets = {} self.CurrentRow, self.CurrentColumn = 0, 0 self.Index = 0 self.tock = 0 self.connection = nil end end function Flipbook:Pause() self.connection:Disconnect() end local Partical = {} Partical.__index = Partical local function evalNumberSequence(sequence, time) if time == 0 then return sequence.Keypoints[1].Value elseif time == 1 then return sequence.Keypoints[#sequence.Keypoints].Value end for i = 1, #sequence.Keypoints - 1 do local currKeypoint = sequence.Keypoints[i] local nextKeypoint = sequence.Keypoints[i + 1] if time >= currKeypoint.Time and time < nextKeypoint.Time then local alpha = (time - currKeypoint.Time) / (nextKeypoint.Time - currKeypoint.Time) return currKeypoint.Value + (nextKeypoint.Value - currKeypoint.Value) * alpha end end end local function evalColorSequence(sequence, time) if time == 0 then return sequence.Keypoints[1].Value elseif time == 1 then return sequence.Keypoints[#sequence.Keypoints].Value end for i = 1, #sequence.Keypoints - 1 do local thisKeypoint = sequence.Keypoints[i] local nextKeypoint = sequence.Keypoints[i + 1] if time >= thisKeypoint.Time and time < nextKeypoint.Time then local alpha = (time - thisKeypoint.Time) / (nextKeypoint.Time - thisKeypoint.Time) return Color3.new( (nextKeypoint.Value.R - thisKeypoint.Value.R) * alpha + thisKeypoint.Value.R, (nextKeypoint.Value.G - thisKeypoint.Value.G) * alpha + thisKeypoint.Value.G, (nextKeypoint.Value.B - thisKeypoint.Value.B) * alpha + thisKeypoint.Value.B ) end end end function Partical.new(parent, texture, flipbook , imageDim ,Data) local self = setmetatable({}, Partical) self.flipbook = flipbook self.texture = texture self.imageDim = imageDim self.startPosition = Data.Starting or Vector3D.new(0,0,0) self.endPosition = Data.end_pos self.lineRotate = 0 self.topCircle = Vector3D.new(0,Data.rayon , 0) self.baseRotaion = 0 self.SizeSequence = NumberSequence.new({ NumberSequenceKeypoint.new(0, 50), NumberSequenceKeypoint.new(1, 50), }) self.TransparencySequence= NumberSequence.new({ NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0), }) self._BaseSize = Vector2.new(50 ,50) self._Parent = parent self._UI = Instance.new("ImageLabel") self._UI.Transparency = 1 self._UI.ImageTransparency = 1  self._UI.Parent = parent self._UI.Image = texture self._UI.Size = UDim2.fromOffset(self._BaseSize.X , self._BaseSize.Y) self:set3DPosition(self.startPosition) return self end local function GetDecimales(x) local _,dec = math.modf(x) local NbDecimales = tostring(dec):gsub("0?%.?", "") return #NbDecimales end function Partical:getDistance(data) return Vector3D.Calc(self.startPosition , self.endPosition , data) end function Partical:getCos() local top = Vector3D.new(self.startPosition.X , self.startPosition.Y , 0 ) +self.topCircle local AB = top.Magnitude local BC = (top - self.endPosition).Magnitude local cos_X = BC/AB cos_X = math.max(-1, math.min(1, cos_X)) self.baseRotaion =( math.acos(cos_X)* (180 / math.pi)) end function Partical:setTransparency(value) self.TransparencySequence = value return self end function Partical:setSize(value) self.SizeSequence = value return self end function Partical:setParent(parent) self._Parent = parent self._UI.Parent = parent return self end function Partical:setRotSpeed(speed) self._UI.Rotation += (math.random(speed.Min, speed.Max)/360) return self end function Partical:setRotation(rot) self._UI.Rotation = rot + self.baseRotaion return self end function Partical:setColor(color) self.ColorsSequence = color return self end function Partical:set3DPosition(pos) local xPos = pos.X local yPos = pos.Y local zDepth = pos.Z self._UI.Position = UDim2.fromOffset( xPos, yPos) local zFactor = math.max(0.1, 1 - (zDepth / math.sqrt(self._BaseSize.X^2 + self._BaseSize.Y^2))) self._UI.Size = UDim2.fromOffset( self._BaseSize.X * (zFactor), self._BaseSize.Y * (zFactor)) return self end function Partical:start(speed , RotSpeed , lift) local newSpeed =randomFloatBetween(speed.Min , speed.Max) local lifeTime =randomFloatBetween(lift.Min , lift.Max) local data = self:getDistance({speed=newSpeed}) local animate if  self.flipbook:lower()  ~= "none" then animate = Flipbook.new(self._UI , self.imageDim , self.flipbook ,1 ) animate:Start() end local startTime = tick() spawn(function() while tick() - startTime <lifeTime do local elapsed = tick() - startTime local alpha = math.clamp(elapsed / lifeTime, 0, 1) self.startPosition += (data["direction"] * ( newSpeed)) self:set3DPosition( self.startPosition) local currentSize = evalNumberSequence( self.SizeSequence , alpha) local currentTr = evalNumberSequence( self.TransparencySequence , alpha) local currentColor = evalColorSequence(self.ColorsSequence , alpha) self._UI.ImageTransparency = currentTr self._UI.ImageColor3 = currentColor self._BaseSize = Vector2.new(currentSize,currentSize) if animate then animate:increment() end self:setRotSpeed(RotSpeed) task.wait() end animate = nil newSpeed = nil data = nil self:Destroy() end) end function Partical:Destroy() if self._UI then self._UI:Destroy() end for i , v in pairs(self) do if typeof(v) == "table" then table.clear(v) end self[i] = nil end self = nil end local function spreadAngle(radius, numx, numy, x, y, center) local points = {} local startAzimuthRadians = math.rad(0) local endAzimuthRadians = math.rad(y) local startElevationRadians = math.rad(0) local endElevationRadians = math.rad(x) for i = 0, numy - 1 do local theta = startAzimuthRadians + (i / (numy - 1)) * (endAzimuthRadians - startAzimuthRadians) for j = 0, numx - 1 do local phi = startElevationRadians + (j / (numx - 1)) * (endElevationRadians - startElevationRadians) local x = radius * math.sin(phi) * math.cos(theta) local y = radius * math.cos(phi) local z = radius * math.sin(phi) * math.sin(theta) table.insert(points, Vector3D.new(center.X+x,center.Y+(-y),center.Z+ z)) end end return points end local Emitter = {} Emitter.__index=Emitter function Emitter.new(Parent, Texture , imgDim) local self = setmetatable({}, Emitter) self.texture = Texture or "rbxasset://textures/particles/sparkles_main.dds" self.imgDim = imgDim self.rate = 5 self.speed = NumberRange.new(1, 10) self.Flipbook = "None" self.isPlaying = false self.size = NumberSequence.new({ NumberSequenceKeypoint.new(0, 50), NumberSequenceKeypoint.new(1, 50), }) self.LifeTime = NumberRange.new(1, 5) self.squash = 1 self.transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0), }) self.color = ColorSequence.new({ ColorSequenceKeypoint.new(0,Color3.new(1,1,1)), ColorSequenceKeypoint.new(1 , Color3.new(0.133333, 0.192157, 1)) }) self.spreadAngle = Vector2.new(0, 0) self.rotation = 0 self.rotSpeed = NumberRange.new(0) self.startPos = Vector3.new(0,0,0) self.acceleration = Vector3D.new(0,0,0) self.raduis = 0; self._UI = Parent self._Atribute = {} self._Partical = {} self._Points = {} return self end function randomFloatBetween(a, b) return a + (b - a) * math.random() end function Emitter:getSettings() return { texture = self.texture, speed = self.speed, Flipbook = self.Flipbook, isPlaying = self.isPlaying, size = self.size, LifeTime = self.LifeTime, squash = self.squash, transparency = self.transparency, color = self.color, spreadAngle = self.spreadAngle, rotation= self.rotation } end function Emitter:getFlipbook() return self.Flipbook end function Emitter:getAttribute(index) return self._Atribute[index] end function Emitter:getAttributeWithValue(value) for k, v in pairs(self._Atribute) do if v == value then return k end end return nil end function Emitter:setStartPos(value) self.startPos = value return self end function Emitter:setColor(value) self.color = value return self end function Emitter:setTexture(id) self.texture = id return self end function Emitter:setSize(size) self.size = size return self end function Emitter:setLifeTime(min , max) self.LifeTime = NumberRange.new(min or 0 , max or min or 0) return self end function Emitter:setSpeed(min , max) self.speed = NumberRange.new(min or 0 , max or min or 0) return self end function Emitter:setSquash(Value) if Value >= 5 then Value = 5 end self.squash = Value return self end function Emitter:setTransparency(Value) self.transparency = Value return self end function Emitter:setRotation(Value) self.rotation = Value return self end function Emitter:setAcceleration(Value) self.acceleration = Value return self end function Emitter:setRotSpeed(min , max) self.rotSpeed = NumberRange.new(min or 0 , max or min or 0) return self end function Emitter:setSpreadAngle(x ,y) table.clear(self._Points) x = x or self.spreadAngle.X y = y or self.spreadAngle.Y self.spreadAngle = Vector2.new(x,y) local numx = 10 local numy = 10 if self.spreadAngle.X >= 5 then self.spreadAngleX= randomFloatBetween(5,self.spreadAngle.X) numx = self.spreadAngleX end if self.spreadAngle.Y >= 5 then self.spreadAngleY= randomFloatBetween(5,self.spreadAngle.X) numy = self.spreadAngleY end self.raduis = randomFloatBetween((self.LifeTime.Min*self.speed.Min),(self.LifeTime.Max*self.speed.Max)) self._Points = spreadAngle( self.raduis, numx , numy, self.spreadAngle.X , self.spreadAngle.Y, Vector3D.new(self.startPos.X , self.startPos.Y , self.startPos.Z) ) return self end function Emitter:Emit(Amount) local rate = Amount or self.rate or 1 self:setSpreadAngle() for i= 0 , rate-1 do local ptc = Partical.new( self._UI , self.texture , self.Flipbook , self.imgDim , { Starting = Vector3D.new(self.startPos.X,self.startPos.Y,self.startPos.Z) , end_pos=self._Points[math.random(1,#self._Points) ] + self.acceleration , rayon= self.raduis } ) ptc:setColor(self.color) ptc:setSize(self.size) ptc:setRotation(self.rotation) ptc:setTransparency(self.transparency) if self.speed.Min == 0 then self.speed = NumberRange.new(1, math.max(self.speed.Max or 5, 1)) end if self.speed.Max == 0 then self.speed = NumberRange.new(self.speed.Min or 1, math.max(self.speed.Min + 4, self.speed.Min)) end ptc:start(self.speed , self.rotSpeed ,self.LifeTime) table.insert(self._Partical , ptc) end end function Emitter:Destroy() self._UI:Destroy() for i ,v in pairs(self) do if typeof(v) == "table" then table.clear(v) end self[i] = nil end table.clear(self) self = nil end getfenv().ParticalEmitter = Emitter else warn("'+msg+'") end '

